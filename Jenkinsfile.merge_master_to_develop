// Merge master to develop.
// If any merge conflicts, report to Slack.
// If success, push branch.

import org.jenkinsci.plugins.workflow.steps.FlowInterruptedException
import groovy.transform.Field

// Shared libraries, configured in https://ci.senseilabs.com/configure.
// Ref https://jenkins.io/doc/book/pipeline/shared-libraries/
@Library('genome') _
githelper = new org.klick.Git()

// Config:
CODE_GITHUB_ORG = 'KlickInc'
CODE_REPO_NAME = 'klick-genome'
CODE_GITHUB_ORG = 'jeff-zohrab'  // TODO - fix this
CODE_REPO_NAME = 'klick-genome-CI-stub'  // TODO - fix this

MERGER_USERNAME = 'sensei-jenkins'
MERGER_EMAIL = 'sensei-jenkins@ci.senseilabs.com'
SLACK_CHANNEL = '#jenkins-dev-tests'


node('sensei_build') {

  create_dir("c:\\www")
  ws("c:\\www\\genome") {

    try {
      checkout()
      fetch()
      merge()
      // push_merged_branch()  // TODO - remove this
      report_success()
      currentBuild.result = 'SUCCESS'
    }
    catch(FlowInterruptedException interruptEx) {
      currentBuild.result = 'ABORTED'
    }
    catch(err) {
      def msg = "Error: ${err.message}"
      if(have_conflicts()) {
        msg = build_merge_failure_message()
      }
      echo msg
      report_failure(msg)
      currentBuild.result = 'FAILURE'
    }
    finally {
      cleanWs()
    }

  } // end ws()

}  // end node


///////////////////////////////////////////////////
// Helpers


def create_dir(dirname) {
  dir(dirname) {
    // Ref https://stackoverflow.com/questions/42654875/jenkins-pipeline-create-directory
    writeFile file: 'placeholder.txt', text: 'Dummy file to create directory.'
  }
  // Remove dummy file, leaving directory behind.
  bat "del ${dirname}\\placeholder.txt"
}


def checkout() {
  stage('Checkout') {
    cleanWs()
    checkout_args = [
      workspace_dir: env.WORKSPACE,
      branch_name: 'develop',
      github_org: CODE_GITHUB_ORG,
      repo_name: CODE_REPO_NAME,
      ref_repo_parent_dir: 'c:\\reference_repo',
      creds_id: 'github-ci'
    ]
    githelper.checkout_from_reference_repo(checkout_args)
  }
}


// Some commands may fail, which is annoying but shouldn't be fatal.
def bat_no_fail(command) {
  try {
    bat command
  }
  catch(err) {
    echo "SWALLOW EXCEPTION FOR COMMAND: ${command}"
  }
}


def fetch() {
  stage('Fetch') {
    do_fetch()
  }
}

def merge() {
  stage('Merge') {
    // User is required to sign the merge commit.
    bat "git config --global user.email \"${MERGER_EMAIL}\""
    bat "git config --global user.name \"${MERGER_USERNAME}\""

    // An error is raised if there are merge conflicts.
    bat "git merge master --no-ff -m \"Merge master into develop.\""
  }
}


// Create a remote reference to the upstream repo,
// execute the "commands" closure, and remove
// the reference.
// This minimizes the exposure of the credentials
// which are stored with the reference. :-(
def with_upstream_context(args, commands) {
  bat_no_fail("git remote remove upstream")
  withCredentials([usernamePassword(credentialsId: args.creds_id, passwordVariable: 'P', usernameVariable: 'U')]) {
    bat "git remote add upstream https://${U}:${P}@github.com/${args.github_org}/${args.repo_name}.git"
  } // end with
  try {
    commands()
  }
  finally {
    bat_no_fail("git remote remove upstream")
  }
}


// Fetch master and develop from the source repo.
//
// We have to fetch the branches or we get an error:
// "fatal: refusing to merge unrelated histories".
//
// Note that using "--allow-unrelated-histories" and fetching to --depth=1 (e.g.)
// (ref https://stackoverflow.com/questions/37937984/git-refusing-to-merge-unrelated-histories-on-rebase)
// does NOT WORK in the following situation:
//    step 1. a file is added to dev
//    step 2. dev was merged to master
//    step 3. a few commits are added to both dev and master
//    step 4. try merge with --allow-unrelated-histories FAILS
// Reason for the failure: with --depth=1, it looks like both branches have added the new file F,
// and it will be reported as a conflict ("git status" shows "both added: F")
//
// The final command we use to fetch is _by far_ the fastest
// (e.g., it takes about 10 seconds for the fetch, rather than
// several minutes), and it yields mergeable branches.
//
// Leaving the other comments in here for posterity,
// and in case anyone thinks of revising the method.
def do_fetch() {
  args = [
    creds_id: 'github-ci',
    github_org: CODE_GITHUB_ORG,
    repo_name: CODE_REPO_NAME
  ]
  with_upstream_context(args) {
    echo "Initial state:"
    bat "git log -n 1 --oneline"
    list_branches("initial state")

    // This works, but takes ~6 mins to fetch to AWS Jenkins slave.
    // bat "git fetch --progress --depth=1000 --no-tags upstream master:refs/remotes/upstream/master"
    // bat "git fetch --progress --depth=1000 --no-tags upstream develop:refs/remotes/upstream/develop"

    // This fetches branches and tags we don't need, and takes ~7 mins.
    // "unshallow" the repo. Note the weird, sort-of-undocumented "--shallow-since" param value.
    // ref https://git-scm.com/docs/git-fetch
    // bat "git fetch --progress --shallow-since=1week upstream"

    // Both of the above methods require us to create and update branches as follows:
    // // The current checkout is by sha (to a detached HEAD), so switch to an actual branch for merging.
    // bat "git checkout upstream/develop -b develop"
    // // Ensure local master branch is the same as upstream (ref https://stackoverflow.com/questions/5471174/)
    // bat "git branch -f master upstream/master"

    // This _appears_ to work as expected, and --shallow-since also appears to limit scope.
    // Ref https://git-scm.com/docs/git-fetch#git-fetch-ltrefspecgt and
    // https://git-scm.com/docs/git-fetch#_examples for notes on "+develop:develop"
    bat "git fetch --progress --no-tags --shallow-since=1week upstream +develop:develop +master:master"

    // We were on a detached HEAD, but now we'll be using upstream/develop.
    bat "git checkout develop"
    
    // Validating:
    list_branches("after checkout")
    bat "git log -n 1 --oneline"
    bat "git log -n 1 develop --oneline"
    bat "git log -n 1 master --oneline"
  }

  list_branches("after leaving context")
}


def list_branches(msg) {
  echo "List branches (${msg})"
  bat "git branch"
  bat "git branch -r"
}


def files_with_conflicts() {
  def conflicts = ""
  conflicts = bat returnStdout: true, script: 'git diff --name-only --diff-filter=U'
  return conflicts.
    split("\n").
    findAll { it.trim() != '' }.
    findAll { !it.contains('git diff') }
}


def have_conflicts() {
  return (files_with_conflicts().size() > 0)
}


def push_merged_branch() {
  stage('Push') {
    args = [
      creds_id: 'github-ci',
      github_org: CODE_GITHUB_ORG,
      repo_name: CODE_REPO_NAME
    ]
    with_upstream_context(args) {
      bat "git push upstream develop"
    }
  }
}


// =============================
// Report failure

def build_merge_failure_message() {
  def show_count = 5
  def files = files_with_conflicts()
  def top_files = files.take(show_count)
  report_top_files = top_files.collect { s -> " * ${s}" }
  def addendum = ''
  if (files.size() > show_count) {
    addendum = "_... and ${files.size() - show_count} more_"
  }

  return """Conflicts:
${report_top_files.join('\n')}
${addendum}

Please fix the conflicts in a new feature branch, e.g.:

```
git fetch
git checkout origin/develop -b feature/<date>-resolve-master-conflicts
git merge origin/master  # ... and fix the conflicts
```
"""
} // 


def report_failure(content) {
  def failure_msg = """*Merge of master into develop failed.*

${content}

${env.Job_URL} (number ${currentBuild.number})"""

  slackSend channel: SLACK_CHANNEL,
    color: '#ff0000',
    message: failure_msg,
    teamDomain: 'senseilabs',
    tokenCredentialId: 'senseilabs-slack-token'
}

def report_success() {
  def msg = """*Merge of master into develop succeeded.* :tada:

${env.Job_URL} (number ${currentBuild.number})"""

  slackSend channel: SLACK_CHANNEL,
    color: '#008000',
    message: msg,
    teamDomain: 'senseilabs',
    tokenCredentialId: 'senseilabs-slack-token'
}
