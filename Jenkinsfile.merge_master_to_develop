// Merge master to develop.
// If any merge conflicts, report to Slack.
// If success, push branch.

import org.jenkinsci.plugins.workflow.steps.FlowInterruptedException
import groovy.transform.Field

// Shared libraries, configured in https://ci.senseilabs.com/configure.
// Ref https://jenkins.io/doc/book/pipeline/shared-libraries/
@Library('genome') _
githelper = new org.klick.Git()

// Config:
CODE_GITHUB_ORG = 'KlickInc'
CODE_REPO_NAME = 'klick-genome'
MERGER_USERNAME = 'sensei-jenkins'
MERGER_EMAIL = 'sensei-jenkins@ci.senseilabs.com'
SLACK_CHANNEL = '#jenkins-dev-tests'


node('sensei_build') {

  create_dir("c:\\www")
  ws("c:\\www\\genome") {

    try {
      checkout()
      try_merge()
      // push_merged_branch()
      report_success()
      currentBuild.result = 'SUCCESS'
    }
    catch(FlowInterruptedException interruptEx) {
      currentBuild.result = 'ABORTED'
    }
    catch(err) {
      def msg = "Error: ${err}"
      if(have_conflicts()) {
        msg = build_merge_failure_message()
      }
      echo msg
      report_failure(msg)
      currentBuild.result = 'FAILURE'
    }
    finally {
      cleanWs()
    }

  } // end ws()

}  // end node


///////////////////////////////////////////////////
// Helpers


def create_dir(dirname) {
  dir(dirname) {
    // Ref https://stackoverflow.com/questions/42654875/jenkins-pipeline-create-directory
    writeFile file: 'placeholder.txt', text: 'Dummy file to create directory.'
  }
  // Remove dummy file, leaving directory behind.
  bat "del ${dirname}\\placeholder.txt"
}


def checkout() {
  stage('Checkout') {
    cleanWs()
    checkout_args = [
      workspace_dir: env.WORKSPACE,
      branch_name: 'develop',
      github_org: CODE_GITHUB_ORG,
      repo_name: CODE_REPO_NAME,
      ref_repo_parent_dir: 'c:\\reference_repo',
      creds_id: 'github-ci'
    ]
    githelper.checkout_from_reference_repo(checkout_args)
  }
}


// Some commands may fail, which is annoying but shouldn't be fatal.
def bat_no_fail(command) {
  try {
    bat command
  }
  catch(err) {
    echo "SWALLOW EXCEPTION FOR COMMAND: ${command}"
  }
}


def try_merge() {
  stage('Merge') {
    set_git_user()
    merge()
  }
}


// User is required to sign the merge commit.
def set_git_user() {
  bat "git config --global user.email \"${MERGER_EMAIL}\""
  bat "git config --global user.name \"${MERGER_USERNAME}\""
}


// Create a remote reference to the upstream repo,
// execute the "commands" closure, and remove
// the reference.
// This minimizes the exposure of the credentials
// which are stored with the reference. :-(
def with_upstream_context(args, commands) {
  bat_no_fail("git remote remove upstream")
  withCredentials([usernamePassword(credentialsId: args.creds_id, passwordVariable: 'P', usernameVariable: 'U')]) {
    bat "git remote add upstream https://${U}:${P}@github.com/${args.github_org}/${args.repo_name}.git"
  } // end with
  try {
    commands()
  }
  finally {
    bat_no_fail("git remote remove upstream")
  }
}


def merge() {
  args = [
    creds_id: 'github-ci',
    github_org: CODE_GITHUB_ORG,
    repo_name: CODE_REPO_NAME
  ]
  with_upstream_context(args) {
    // list_branches("initial state")

    // Delete the current master, which points to the
    // reference repository, and fetch from upstream.
    bat "git branch -D master"

    // Fetch master and develop from upstream.
    // Fetch --depth=1000 to avoid error "fatal: refusing to merge unrelated histories".
    // Note this step may not be necessary if we use "--allow-unrelated-histories"
    // (see https://stackoverflow.com/questions/37937984/git-refusing-to-merge-unrelated-histories-on-rebase),
    // but it feels safer to just pull in the full tree.
    bat "git fetch --progress --depth=1000 --no-tags upstream master:refs/remotes/upstream/master"
    bat "git fetch --progress --depth=1000 --no-tags upstream develop:refs/remotes/upstream/develop"

    // The current checkout is by sha (to a detached HEAD),
    // so switch to an actual branch for merging.
    bat "git checkout upstream/develop -b develop"

    // An error is raised if there are merge conflicts.
    bat "git merge upstream/master --no-ff -m \"Merge master into develop.\""

    // list_branches("before leaving context")
  }

  // list_branches("after leaving context")
}


def list_branches(msg) {
  echo "List branches (${msg})"
  bat "git branch"
  bat "git branch -r"
}


def files_with_conflicts() {
  def conflicts = ""
  conflicts = bat returnStdout: true, script: 'git diff --name-only --diff-filter=U'
  return conflicts.
    split("\n").
    findAll { it.trim() != '' }.
    findAll { !it.contains('git diff') }
}


def have_conflicts() {
  return (files_with_conflicts().size() > 0)
}


def push_merged_branch() {
  stage('Push') {
    args = [
      creds_id: 'github-ci',
      github_org: CODE_GITHUB_ORG,
      repo_name: CODE_REPO_NAME
    ]
    with_upstream_context(args) {
      bat "git push upstream develop"
    }
  }
}


// =============================
// Report failure

def build_merge_failure_message() {
  def show_count = 5
  def files = files_with_conflicts()
  def top_files = files.take(show_count)
  report_top_files = top_files.collect { s -> " * ${s}" }
  def addendum = ''
  if (files.size() > show_count) {
    addendum = "_... and ${files.size() - show_count} more_"
  }

  return """Conflicts:
${report_top_files.join('\n')}
${addendum}

Please fix the conflicts in a new feature branch, e.g.:

```
git fetch
git checkout origin/develop -b feature/<date>-resolve-master-conflicts
git merge origin/master  # ... and fix the conflicts
```
"""
} // 


def report_failure(content) {
  def failure_msg = """*Merge of master into develop failed.*

${content}

${env.Job_URL} (number ${currentBuild.number})"""

  slackSend channel: SLACK_CHANNEL,
    color: '#ff0000',
    message: failure_msg,
    teamDomain: 'senseilabs',
    tokenCredentialId: 'senseilabs-slack-token'
}

def report_success() {
  def msg = """*Merge of master into develop succeeded.* :tada:

${env.Job_URL} (number ${currentBuild.number})"""

  slackSend channel: SLACK_CHANNEL,
    color: '#008000',
    message: msg,
    teamDomain: 'senseilabs',
    tokenCredentialId: 'senseilabs-slack-token'
}
