// Merge master to develop.
// If any merge conflicts, report to Slack.
// If success, push branch.

import org.jenkinsci.plugins.workflow.steps.FlowInterruptedException
import groovy.transform.Field

// Shared libraries, configured in https://ci.senseilabs.com/configure.
// Ref https://jenkins.io/doc/book/pipeline/shared-libraries/
@Library('genome') _
genome = new org.klick.Genome()
githelper = new org.klick.Git()

// Repo:
CODE_GITHUB_ORG = 'jeff-zohrab'  // TODO - fix this
CODE_REPO_NAME = 'klick-genome-CI-stub'  // TODO - fix this

// Slack channel to report to.
slack_channel = '#jenkins-dev-tests'

node('sensei_build') {

  genome.create_dir("c:\\www")
  ws("c:\\www\\genome") {

    try {
      checkout()
      try_merge()
    }
    catch(FlowInterruptedException interruptEx) {
      currentBuild.result = 'ABORTED'
    }
    catch(err) {
      def msg = "Error: ${err}"
      echo msg
      report_failure(msg)
      currentBuild.result = 'FAILURE'
    }
    finally {
      cleanWs()
    }

  } // end ws()

}  // end node


///////////////////////////////////////////////////
// Helpers


def checkout() {
  stage('Checkout') {
    genome.stop_iis()  // Must use a shared lib, local repo isn't checked out yet.
    cleanWs()
    checkout_args = [
      workspace_dir: env.WORKSPACE,
      branch_name: 'develop',
      github_org: CODE_GITHUB_ORG,
      repo_name: CODE_REPO_NAME,
      ref_repo_parent_dir: 'c:\\reference_repo',
      creds_id: 'github-ci'
    ]
    githelper.checkout_from_reference_repo(checkout_args)
  }
}


// Some commands may fail, which is annoying but shouldn't be fatal.
def bat_no_fail(command) {
  try {
    bat command
  }
  catch(err) {
    echo "SWALLOW EXCEPTION FOR COMMAND: ${command}"
  }
}


def try_merge() {
  stage('Merge') {
    set_user()
    merge()
    if(have_conflicts()) {
      report_failure(build_merge_failure_message())
      currentBuild.result = 'FAILURE'
    }
    else {
      push_merged_branch()
      currentBuild.result = 'SUCCESS'
    }
  }
}

// User is required to sign the merge commit.
def set_user() {
  bat "git config --global user.email \"jzohrab@gmail.com\""  // TODO fix
  bat "git config --global user.name \"Jeff Zohrab\""  // TODO fix
}


// Create a remote reference to the upstream repo,
// execute the "commands" closure, and remove
// the reference.
// This minimizes the exposure of the credentials
// which are stored with the reference. :-(
def with_upstream_context(args, commands) {
  bat_no_fail("git remote remove upstream")
  withCredentials([usernamePassword(credentialsId: args.creds_id, passwordVariable: 'P', usernameVariable: 'U')]) {
    bat "git remote add upstream https://${U}:${P}@github.com/${args.github_org}/${args.repo_name}.git"
  } // end with
  try {
    commands()
  }
  finally {
    bat_no_fail("git remote remove upstream")
  }
}


def merge() {
  stage('Merge master') {
    args = [
      creds_id: 'github-ci',
      github_org: CODE_GITHUB_ORG,
      repo_name: CODE_REPO_NAME
    ]
    with_upstream_context(args) {
      // echo "Branches, initial state:"
      // bat "git branch"
      // bat "git branch -r"

      // Delete the current master, which points to the
      // reference repository, and fetch from upstream.
      bat "git branch -D master"

      // Fetch master and develop from upstream.
      // Fetch --depth=1000 to avoid error "fatal: refusing to merge unrelated histories".
      bat "git fetch --depth=1000 --no-tags upstream master:refs/remotes/upstream/master"
      bat "git fetch --depth=1000 --no-tags upstream develop:refs/remotes/upstream/develop"
      
      // The current checkout is by sha (to a detached HEAD),
      // so switch to an actual branch for merging.
      bat "git checkout upstream/develop -b develop"

      // Merge conflicts raise an error, so ignore them for later processing.
      bat_no_fail("git merge upstream/master -m \"Merge master into develop.\"")

      // echo "Branches, before leaving context:"
      // bat "git branch"
      // bat "git branch -r"
    }

    // echo "Branches, after leaving context:"
    // bat "git branch"
    // bat "git branch -r"
  }
}


def files_with_conflicts() {
  def conflicts = ""
  conflicts = bat returnStdout: true, script: 'git diff --name-only --diff-filter=U'
  return conflicts.
    split("\n").
    findAll { it.trim() != '' }.
    findAll { !it.contains('git diff') }
}


def have_conflicts() {
  return (files_with_conflicts().size() > 0)
}


def push_merged_branch() {
  stage('Push merged branch') {
    args = [
      creds_id: 'github-ci',
      github_org: CODE_GITHUB_ORG,
      repo_name: CODE_REPO_NAME
    ]
    with_upstream_context(args) {
      bat "git push upstream develop"
    }
  }
}


// =============================
// Report failure

def build_merge_failure_message() {
  def show_count = 5
  def files = files_with_conflicts()
  def top_files = files.take(show_count)
  report_top_files = top_files.collect { s -> " * ${s}" }
  def addendum = ''
  if (files.size() > show_count) {
    addendum = "_... and ${files.size() - show_count} more_"
  }

  return """Conflicts:
${report_top_files.join('\n')}
${addendum}

Please fix the conflicts in a new feature branch, e.g.:

```
git fetch
git checkout origin/develop -b feature/<date>-resolve-master-conflicts
git merge origin/master  # ... and fix the conflicts
```
"""
} // 


def report_failure(content) {
  def failure_msg = """*Merge of master into develop failed.*

${content}

${env.Job_URL} (number ${currentBuild.number})"""

  slackSend channel: slack_channel,
    color: '#ff0000',
    message: failure_msg,
    teamDomain: 'senseilabs',
    tokenCredentialId: 'senseilabs-slack-token'
}
